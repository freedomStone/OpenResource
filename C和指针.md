## 快速上手
#### 空白和注释
如果想真正删除一段C代码而又保留记录，此时使用注释并不能完美实现，更好更安全的办法是使用#if指令：
```c
#if 0
    statements
#endif
```
#### 预处理
对于#define,由于其定义字面值常量，故其不能出现于普通变量出现的场合（比如赋值符左边）

#### 参数传递
所有传递给函数的参数都是按值传递的。但是当数组名（指针变量）作为参数时会产生应用传递的效果。

#### 数组下标有效性
标准并未硬性规定C编译器对数组下标的有效性进行检查，而且绝大多数C编译器确实也不进行检查。因此，如果你需要进行数组下标有效性检查，你必须自行编写代码。  
如果下标值是从已知是正确的值计算得来，可不用检查；如果是从用户输入等不可信的数据产生来的，则使用之前必须进行下标检验。

#### 字符变量
用于存储单个字符的变量可以声明未整型，因为整型位数比字符类型位数多，声明为整型可以在用于输入时读取返回EOF发生错误。  
字符只是小型整数，使用整型变量容纳字符值不会引起任何问题。

#### 一些警告
- 在scanf函数的标量参数前未添加&符号
- 机械的把printf函数的格式代码照搬于scanf函数
- 在应该使用&&操作符的地方误用了&操作符
- 误用=操作符而不是==操作符来测试相等性。


## 基本概念
#### 三字母词trigrph
是几个字符的序列，合起来表示另一个字符。适用于编译器不支持某些字符时，一般极少使用，但遇到双问号时需要注意误用，现代编译器一般禁用三字母词，但会产生警告消息。三字母词例如：  
|三字母词|表示|三字母词|表示|三字母词|表示|
|-|-|-|-|-|-|
|??\(|\[|??<|{|??=|#|
|??\)|\]|??>|}|??/|\\ |
|??!|\||??'|^|??-|~|


## 数据
#### 整型
- 长整型至少应该和整型一样长，而整型至少应该和短整型一样长。
- 头文件limits.h说明了各种不同整数类型的特点。
- 缺省的char是signed还是unsigned取决于编译器，故只有程序所属变量值位于signed和unsigned交集中时程序才可移植。或者显示的声明signed或unsigned，但有时会影响效率和兼容性问题。

#### 枚举类型
- 枚举的变量实际上以整型的方式存储，符号名的实际值都是整型值。但应避免与整型混用。
- 如果某个符号名未显示的指定一个值，那么它的值就比前一个符号名的值大1。如果都未指定值，则首个符号名从0开始。

#### 浮点类型
- 所有浮点类型至少能容纳$10^{-37}$和$10^{37}$之间的任何值。
- 头文件float.h定义了浮点类型能存储的最值。

#### 指针
- 对于字符串常量，ANSI C中对一个字符进行修改其效果是未定义的，因此如果需要修改字符串，需要把它存放于数组中。
- 不能直接把字符串常量赋值给一个祖父数组，因为字符串常量的直接值是一个指针，而不是字符本身，可使用memcpy等函数赋值。
- 指针声明\*的合理位置：
  ```c
  int *a;
  //区分下面的声明，理解*位置的合理型。
  int* a,b,c;
  int *a,*b,*c;
  ```

#### typedef
```c
//将ptr_to_char作为指向字符的指针类型
typedef char *ptr_to_char;

//下面两个等价
ptr_to_char a;
char *a;
```

#### const
- 修饰基本数据类型：const可放在类型说明前也可放在其后，使用常量时不改变常量值
- 修饰指针变量和引用变量：对于const \*用来修饰指针所指向的变量即指针所指向的为一个常量；对于\* const用来修饰注重本身即指针本身为常量
  ```c
  const int * p1;//指向整形常量的指针，它指向的值不可修改
  int * const p2;//指向整形变量的常量指针，它不能指向别的变量，但指向变量的值可以改变
  const int * const p3;//指向整形常量的常量指针，它既不能指向别的常量，指向的值也不能修改
  ```
- 应用到函数中：修饰参数时当调用函数时，用对应变量初始化该参数，在函数体重，对该参数进行常量化，保护了原对象的属性（const通常用于参数为指针或应用的情况）；修饰函数返回值时，声明返回值后，也起到相应保护作用。

#### 作用域scope
- 代码块作用域
- 文件作用域
- 原型作用域
- 函数作用域

#### 链接属性
- external：可被其他文件访问到
- internal：只能在当前文件中访问到
- none：总是被当做单独个体  
  
属于文件作用域的声明缺省情况下为external。

#### 存储类型
- 静态变量：在代码块之外声明的变量总是存储于静态内存中，即不属于堆内存。
- 自动变量：存储于堆栈中，当程序执行到声明变量位置时变量才会被创建。

#### static
- 当它用于函数定义，或用于代码块之外的变量声明时，用于修改标识符的链接属性，从external改为internal，但标识符的存储类型和作用域不受影响。可以使得函数或变量只能在声明它们的源文件中访问。
- 当用于代码块内部的变量声明时，用于修改变量的存储类型，从自动变量修改为静态变量，但变量的链接属性和作用域不受影响。可以使该变量在程序执行之前创建，并在程序执行期间一直存在，而不是每次在代码块开始执行时创建或销毁。


## 语句
#### 空语句
只包含一个分号。适用场景是语法要求一条完整的语句，但不需要执行任何任务。

#### if语句  
else子句从属于最靠近它的不完整if语句。

#### goto语句
可用于跳出多层嵌套循环。这种场景若不用goto其替代方案是所有循环设置状态标志或者把所有的循环都放在单独的函数里，结合return解决。

## 操作符和表达式
#### 移位操作符
- 左移：<<
  - 左边丢弃，右边补0
- 右移：>>
  - 逻辑移位：右边丢弃，左边补0
  - 算术移位：右边丢弃，符号为1则左边补1，符号为0则左边补0
- 仅对有符号值，右移采用算术移位还是逻辑移位取决于编译器。故有符号位的右移位操作不利于移植。
- 移位操作数为负值，例如a << -5;是一种未定义行为，由编译器决定，比如可能实际执行的是左移27位。

#### 位的操纵
```c
//bit_number表示指定位
//把指定的位置设置为1
value = value | 1 << bit_number;
//把指定的位置设置为1
value |= 1 << bit_number;
//把指定的位置清0
value = value & ~(1 << bit_number);
//把指定的位置清0
value &= ~(1 << bit_number);
//对指定位进行测试判断是否为1
value & 1 << bit_number;
```

#### 逗号操作符
从左到右逐个表达式进行求值，整个逗号表达式的值是最后那个表达式的值。

#### 布尔值
C并不具备布尔类型，而是用整型代替。零值表示假，非零值表示真。关系操作符的结果是整型值0或1。  
可定义FALSE和TRUE宏来方便编码，但此时又要注意TRUE与非0整型间的比较。  
避免混用整型值和布尔值！！

#### 优先级与求值顺序
编译器只要不违背优先级和结合性原则，它可以自由决定复杂表达式的求值顺序。表达式的结果如歌依赖于求值顺序，那么它的本质是不可移植的。  
一个证明表达式求值顺序只是部分由操作数优先级决定的例子，不同编译器结果不一定一致：
```c
void main()
{
    int i = 10;
    i = i-- - --i * (i = -3) * i++ + ++i;
    printf("i = %d\n",i);
}
```

## 指针 
#### 未初始化和非法的指针
一个常见的错误用例：
```c
int *a;
*a = 12;
```
上述代码并未确定a指向什么位置。  
如果变量是静态的会被初始化为0，但如果变量是自动的，它根本不会被初始化。  
上面的赋值操作可能导致“段违例”（segmentation violation）或内存错误。  

#### *p++
++优先级比\*高,所以执行过程如下：
- ++操作符产生一份p的拷贝
- 然后++操作符增加p的值（地址后移）
- 在p拷贝的基础上执行间接访问操作

#### 算术运算
- 形式一：指针$\plusmn$整数
  - 适用于指向数组的指针
  - 适用于malloc函数动态分配获得的内存地址
- 形式二：指针 - 指针
  - 适用于指向数组的指针

#### 关系运算
对于关系运算符，仅适用于指向同一数组的指针 

## 函数
#### K&R C
在K&R C中，形式参数的类型以单独的列表进行声明，并出现在参数列表和函数体的左花括号之间。
```c
int *
find_int(key, array, array_len)
int key;
int array[];
int array_len;
{
  //...
}
```
这种声明形式现在仍为标准所允许，主要是为了让较老的程序无需修改便可通过编译。  
不提倡使用这种声明形式。

#### 没有参数的函数原型
```c
int *func(void);
//下面这种形式，会被解释为K&R C风格的声明，由于编译器不记录旧风格函数原型的参数信息，所有并不能确定没有参数
int *func();
```

#### 函数的缺省认定
当程序调用一个无法见到原型的函数时，编译器便认为该函数返回一个整型值。对于哪些并不返回整型值的函数，则会引起错误。

#### 可变参数列表
通过宏来实现，定义于stdarg.h头文件中。该头文件声明了一个类型va_list和三个宏va_start、va_arg和va_end。  
可变参数必须从头到尾按照顺序逐个访问。  
```c
#include<stdarg.h>
//n_values这个参数为命名参数，不可省略，使用可变参数时使用"..."记法
float average(int n_values, ...)
{
  //声明var_arg用于访问参数列表中的未确定部分
  va_list var_arg;
  int count;
  float sum = 0;

  //va_start第1个参数为va_list变量,第二个参数是省略号...前最后一个有名字的参数
  //准备访问可变参数，将var_arg变量设置为指向可变参数部分的第1个参数
  va_start(var_arg, n_values);

  //添加取自可变参数列表的值
  for(count = 0; count < n_values, count += 1)
  {
    //va_arg接受两个参数，va_list变量和参数列表中下一个参数的类型
    //va_arg返回值为当前可变参数的值，并使var_arg指向下一个可变参数
    sum += va_arg(var_arg, int);
  }
  //完成处理可变参数
  va_end(var_arg);

  return sum / n_values;
}
```
有两个使用限制：
- 宏无法判断实际存在的参数的数量
- 宏无法判断每个参数的类型
为解决上面的限制，必须使用命名参数来解决，例如上面例子中的n_values指定了数量。另外一个例子是printf函数，它的命名参数通过格式字符串，不仅指定了参数数量也指定了参数类型。


## 数组
#### 数组名的类型
```c
int b[10];
```
以上b[4]的类型是整型，b的类型是“指向int的常量指针”。  
数组和指针并不完全相同。只有当数组名在表达式中使用时，编译器才会为它产生一个指针常量。而指针常量的值不可修改。  
只有两种场合，数组名并不能用指针常量来表示：
- 数组名作为sizeof操作符的操作数时：sizeof返回整个数组的长度，而不是指向数组的指针的长度
- 数组名作为单目操作符&的操作数时
```c
int a[10];
int b[10];
int *c;

c = &a[0];//合法
c = a;//合法，和上一行语句等价
b = a;//非法，赋值符不能复制整个数组
a = c;//非法，a为常量不可赋值
```

#### 下标引用
除优先级之外，下标引用和间接访问完全相同
```c
//下面等价
array[i]; //下标引用
*(array + i); //间接访问
```
使用举例：
```c
int array[10];
int *ap = array + 2;

//下面表达式的合法性列举，只保留了语句的表达式部分
ap //合法，等价于&array[2]
*ap //合法,等价于array[2]
ap[0] //合法，等价于*(ap + 0)
ap + 6 //合法,等价于&array[8]
*ap + 6 //合法,等价于array[2] + 6
*(ap + 6) //合法，等价于array[8]
ap[6] //合法，等价于*(ap + 6)
&ap //合法，但无等价的array表达式
ap[-1] // 合法，等价于*(ap - 1)或array[1]

ap[9] //非法，等价于array[11],越界但编译器可能不能检测到这类错误，其行为是未定义的。

2[array] //合法但不推荐，即*(2 + array)等于array[2]
```

#### 使用间接访问更高效
- 当根据某个固定数目的增量在一个数组中移动时，使用指针变量将比使用下标产生效率更高的代码
- 声明为寄存器变量的指针通常比位于静态内存和堆栈中的指针效率更高
- 如果可以通过测试一些已经初始化并经过调整的内容来判断循环是否应该终止，那么就不需要使用单独一个计数器
  ```c
  #define SIZE 10
  int x[SIZE],y[SIZE];
  //register用于声明寄存器变量，这样就不必复制指针值，但是必须被声明为局部变量
  register int *p1, *p2, i;
  //有计数器
  for(int i = 0, p1 =x, p2 =y; i < SIZE, i++)
    *p1++ =*p2++;
  
  //无计数器
  for(p1 = x,p2 = y; p1 < &x[SIZE];)
    *p1++ =*p2++;
  ```
- 那些必须在运行时求值的表达式较之如&array[SIZE]或array + SIZE这样的常量表达式往往代价更高

#### 数组与指针
两者并不总是一致的。数组名是指针常量，而指针往往是一个指针变量。
```c
int a[5];
int *b;

*a //合法
*b //未初始化，故是未定义行为
b++ //合法
a++ //非法，因为a为常量
```
数组名作为函数参数，实际传入的是一份指针常量的拷贝，这份拷贝本质是一个指针变量，故可以对自身进行修改，例如++操作。  
声明数组参数的两种方式是等价的，但是由于传入是一份指针拷贝，对于sizeof这种操作符而言，使用指针形式的声明更准确。
```c
int strlen(char *string);//指针形式
int strlen(char string[]);//数组形式
```
字符串数组和字符串常量并不相同。常量不可修改。
```c
char string1[] = "hello";//字符串数组
char *string2 = "hello";//字符串常量（指针）
```
#### 多维数组
```c
int a;
int b[10];//10列
int c[6][10];//6行10列
int d[3][6][10];//3排6行10列
```
多维数组的存储顺序按照最右边的下标率先变化的原则。即array[0][0]、array[0][1]......
```c
int matrix[6][10];
//下面表达式等价
*(*(matrix + 1) + 5)
matrix[1][5]
*(matrix[1] + 5)
```
声明指向数组的指针：
```c
int vector[10],matrix[3][10];
int *vp = vector;//合法
int *mp = matrix;//非法
//对应的正确的声明
int (*p)[10] = matrix;//合法
//p + 1等价于&matrix[1]而不是&matrix[0][1]

//如果想声明指向matrix并逐个访问元素的指针
int *pi = matrix[0];
int *pi = &matrix[0][0];//等价上面
//pi + 1即&matrix[0][1]
```
对于int (*p)[10]的声明的解读：下标引用高于间接访问，但由于括号存在先看间接访问，指定mp是个指针，然后看指针指向什么,根据表达式求值顺序，指针指向[10]即某种类型的数组,最后看是什么类型数组，往左看是int。最终，p是一个指向拥有10个整型元素数组的指针。  

```c
对于int matrix[3][10]
//多维数组对应的函数传参,下面等价
void func(int (*mat)[10]);
void func(int mat[][10]);
//下面的写法对于此处是错误的,多为数组传参仅第一维可以写成指针形式，其余维度必须写成数组形式
void func(int **mat);

```

#### 指针数组
即数组的元素为指针类型
```c
int *api[10];
```
类似int (*p)[10]声明的解读，由于下标引用高于间接访问，故api是[10]即10个元素的数组，然后看是什么类似的数组，往左发现类型是int *即整型指针。最终，api是一个指向int *的常量指针或者说数组名。
```c
int *api[10];
//指针数组对应的函数传参，下面等价
void func(int **api);
void func(int *api[]);
//或者用更严格的方式：
void func(int *api[10]);
```   


## 字符串、字符和字节
#### 使用有些区别的strncpy和strncat
- strncpy如果len大于要复制的源字符串长度，那么它不会在末尾自动添加'\0';如何源字符串长度小于len那么会自动填充len剩下的长度数量的'\0'
- strncat总是在连接完后添加一个'\0'

#### 使用ctype更有可移植性
以判读字符字母大小写为例
```c
//仅在ASCII字符集机器上运行
if(ch > 'A' && ch < 'Z')

//任意字符集机器上运行
if(issupper(ch))
```
ctype.h包含的字符操作：  
|函数|如果它的参数符合下列条件就返回真|
|-|-|
|iscntrl|任何控制字符|
|isspace|空白字符：空格、换页\f、换行\n、回车\r、制表符\t\v|
|isdight|十进制数字0~9|
|isxdight|十六进制数字0~9a~fA~F|
|islower|小写字母a~z|
|isupper|大写字母A~Z|
|isalpha|字母A~Za~z|
|isalnum|字母或数字A~Za~z0~9|
|ispunct|标点符号,任何不属于数字或字母的图形符号|
|isgraph|任何图形字符|
|isprint|任何可打印字符，包括图形字符和空白字符|  
ctype.h还包含字符的大小写转换
```c
int tolower(int ch);
int toupper(int ch);
```

#### memcpy和memmove的区别
当且仅当源和目标操作数内存空间有重叠时，两者使用有差别。  
如果内存有重叠，memcpy使用则会有未定义行为，此时不能使用。  
而memmove则支持内存重叠时的复制操作，它本质是先把源操作数复制一份到临时空间，再从临时空间复制到目标操作数。


## 结构和联合